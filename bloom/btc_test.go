package bloom_test

import (
	"bytes"
	"testing"

	"github.com/sammyne/bip37"
	"github.com/sammyne/bip37/wire"

	"github.com/btcsuite/btcd/txscript"
	btcwire "github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
	"github.com/sammyne/bip37/bloom"
)

func TestFilter_AddOutPoint(t *testing.T) {
	// these test cases are generated by running the reference impl
	// from btcsuite/btcutil
	testCases := []struct {
		outPoint *btcwire.OutPoint
		expect   []byte
	}{
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("2440cddbc2a189357e7bc0e4f552bfde79e7f6b16d41c32436a67fd6db8f5051"),
				1365930811,
			),
			expect: bip37.Unhexlify("0180020010100010028023010110020000000040000000001000000004000000000008"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("4eae34665dd045f0a5d7c1bfbb3dc7f7dc7e83af6473adb86e5ec294884d16da"),
				2369852057,
			),
			expect: bip37.Unhexlify("c00000800800000100820030004200000a000001400012000000000001000000200000"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("05b1b97ed8376ab33c00bf65edcb6a68951dceeec503a046ce9a0b2e8479ce90"),
				203140287,
			),
			expect: bip37.Unhexlify("000000040000080a040000080280000000000080241010000000020040000080000061"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("4e8968607d8eccdaa973aab3289e5bc50acc24f0d924644ff5ab8e331e222209"),
				439152913,
			),
			expect: bip37.Unhexlify("1800000200090000480100008000002000090800000000080000400000002000008800"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("b2d65d20a076eb5ed9fe107c432a4b18da0d0ff5ffbd844a0aedb3240c8f5015"),
				2452721939,
			),
			expect: bip37.Unhexlify("0000100029008000000800000000001200000000100000000006880800408080810000"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("d2dd5b79a674ab3c59a5455c86e870ef269af79332664999f6c5cd8b62e01902"),
				661960754,
			),
			expect: bip37.Unhexlify("0c80000040000800500000000004010000050300040280002000000000000000400000"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("82155b639c3870f12059a87427e97137a3225e6c98e06714da0ffbedc7ad084d"),
				1834508511,
			),
			expect: bip37.Unhexlify("0200222000000001100020600880000000000000001000100000040800800102010000"),
		},
		{
			outPoint: bip37.NewOutPoint(
				bip37.Unhexlify("b6981b9f5477f82f5bbb65a48c7aee6a05f4ed20e41f091f2781ac150e4ee8e3"),
				1658529405,
			),
			expect: bip37.Unhexlify("0080000200240000000000000000009000000884400400002080040000000000000201"),
		},
	}

	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, Tweak)
		filter.AddOutPoint(c.outPoint)

		if got := filter.Snapshot().Bits; !bytes.Equal(got, c.expect) {
			t.Fatalf("#%d invalid filter: got %x, expect %x", i, got, c.expect)
		}
	}
}

func TestFilter_MatchOutPoint(t *testing.T) {
	// these test cases are generated by running the reference impl
	// from btcsuite/btcutil
	testCases := []*btcwire.OutPoint{
		bip37.NewOutPoint(
			bip37.Unhexlify("2440cddbc2a189357e7bc0e4f552bfde79e7f6b16d41c32436a67fd6db8f5051"),
			1365930811,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("4eae34665dd045f0a5d7c1bfbb3dc7f7dc7e83af6473adb86e5ec294884d16da"),
			2369852057,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("05b1b97ed8376ab33c00bf65edcb6a68951dceeec503a046ce9a0b2e8479ce90"),
			203140287,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("4e8968607d8eccdaa973aab3289e5bc50acc24f0d924644ff5ab8e331e222209"),
			439152913,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("b2d65d20a076eb5ed9fe107c432a4b18da0d0ff5ffbd844a0aedb3240c8f5015"),
			2452721939,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("d2dd5b79a674ab3c59a5455c86e870ef269af79332664999f6c5cd8b62e01902"),
			661960754,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("82155b639c3870f12059a87427e97137a3225e6c98e06714da0ffbedc7ad084d"),
			1834508511,
		),
		bip37.NewOutPoint(
			bip37.Unhexlify("b6981b9f5477f82f5bbb65a48c7aee6a05f4ed20e41f091f2781ac150e4ee8e3"),
			1658529405,
		),
	}

	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, Tweak)
		filter.AddOutPoint(c)

		if !filter.MatchOutPoint(c) {
			t.Fatalf("#%d failed to match the added OutPoint", i)
		}
	}
}

func TestFilter_MatchTx(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateNone
	)

	block := bip37.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bip37.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bip37.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bip37.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bip37.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bip37.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bip37.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bip37.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bip37.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bip37.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTx(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_all(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	block := bip37.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bip37.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bip37.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript#0",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bip37.Unhexlify("04eaafc2314def4ca98ac970241bcab022b9c1e1f4ea423a20f134c876f2c01ec0f0dd5b2e86e7168cefe0d81113c3807420ce13ad1357231a2252247d97a46a91"),
			},
			expect: expect{true, bip37.Unhexlify("0804010120800801100214340b01091100000020102000410100003000110000000102")},
		},
		{
			description: "match elem in output's PkScript#1",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bip37.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bip37.Unhexlify("12001284424202041002028000000e0000110001010030018200000404000c08011000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bip37.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bip37.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bip37.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bip37.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bip37.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_badPkScript(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	block := bip37.ReadBlock(t)

	tx := block.Transactions[1]

	// introduce corruption
	tx.TxOut[0].PkScript = bip37.Unhexlify("6de59c34381a159e95fc6b8775558c5c63bcceeaeb576eb53b")

	out := tx.TxOut[1]
	outData, err := txscript.PushedData(out.PkScript)
	if nil != err {
		t.Fatal(err)
	}
	preAdded := outData[len(outData)-1]

	expect := bip37.Unhexlify("1004020440420225150002002001800010000000010000008200200400008908810410")

	filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
	filter.Add(preAdded)

	if got := filter.MatchTxAndUpdate(btcutil.NewTx(tx)); !got {
		t.Fatalf("matching is expected")
	}

	if bits := filter.Snapshot().Bits; !bytes.Equal(bits, expect) {
		t.Fatalf("invalid bits: got %x, expect %x", bits, expect)
	}
}

func TestFilter_MatchTxAndUpdate_badSignatureScript(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	block := bip37.ReadBlock(t)

	tx := block.Transactions[1]

	// introduce corruption
	//io.ReadFull(rand.Reader, tx.TxIn[0].SignatureScript)
	tx.TxIn[0].SignatureScript = bip37.Unhexlify("4fd580192a4b534058fb7b0bc98324d79dd41c073294889b963880e256aeac810e74f8f178063c318517a37d4eecb2db0f797fa1e9d4bf95f928fb31b583d346554c16613661400e1a")

	expect := bip37.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")

	filter := bloom.New(N, P, UpdateRule, bloom.Tweak)

	if got := filter.MatchTxAndUpdate(btcutil.NewTx(tx)); got {
		t.Fatalf("non-matching is expected")
	}

	if bits := filter.Snapshot().Bits; !bytes.Equal(bits, expect) {
		t.Fatalf("invalid bits: got %x, expect %x", bits, expect)
	}
}

func TestFilter_MatchTxAndUpdate_none(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateNone
	)

	block := bip37.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bip37.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bip37.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bip37.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bip37.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bip37.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bip37.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bip37.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bip37.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bip37.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_p2PubKeyOnly(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateP2PubKeyOnly
	)

	block := bip37.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bip37.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bip37.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript and update",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bip37.Unhexlify("04eaafc2314def4ca98ac970241bcab022b9c1e1f4ea423a20f134c876f2c01ec0f0dd5b2e86e7168cefe0d81113c3807420ce13ad1357231a2252247d97a46a91"),
			},
			expect: expect{true, bip37.Unhexlify("0804010120800801100214340b01091100000020102000410100003000110000000102")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bip37.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bip37.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bip37.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bip37.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bip37.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bip37.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bip37.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}
