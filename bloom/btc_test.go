package bloom_test

import (
	"bytes"
	"testing"

	"github.com/sammy00/bip37/wire"

	"github.com/btcsuite/btcd/txscript"
	btcwire "github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
	btcbloom "github.com/btcsuite/btcutil/bloom"
	"github.com/sammy00/bip37/bloom"
)

func TestFilter_AddOutPoint(t *testing.T) {
	// these test cases are generated by running the reference impl
	// from btcsuite/btcutil
	testCases := []struct {
		outPoint *btcwire.OutPoint
		expect   []byte
	}{
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("2440cddbc2a189357e7bc0e4f552bfde79e7f6b16d41c32436a67fd6db8f5051"),
				1365930811,
			),
			expect: bloom.Unhexlify("0180020010100010028023010110020000000040000000001000000004000000000008"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("4eae34665dd045f0a5d7c1bfbb3dc7f7dc7e83af6473adb86e5ec294884d16da"),
				2369852057,
			),
			expect: bloom.Unhexlify("c00000800800000100820030004200000a000001400012000000000001000000200000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("05b1b97ed8376ab33c00bf65edcb6a68951dceeec503a046ce9a0b2e8479ce90"),
				203140287,
			),
			expect: bloom.Unhexlify("000000040000080a040000080280000000000080241010000000020040000080000061"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("4e8968607d8eccdaa973aab3289e5bc50acc24f0d924644ff5ab8e331e222209"),
				439152913,
			),
			expect: bloom.Unhexlify("1800000200090000480100008000002000090800000000080000400000002000008800"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("b2d65d20a076eb5ed9fe107c432a4b18da0d0ff5ffbd844a0aedb3240c8f5015"),
				2452721939,
			),
			expect: bloom.Unhexlify("0000100029008000000800000000001200000000100000000006880800408080810000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("d2dd5b79a674ab3c59a5455c86e870ef269af79332664999f6c5cd8b62e01902"),
				661960754,
			),
			expect: bloom.Unhexlify("0c80000040000800500000000004010000050300040280002000000000000000400000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("82155b639c3870f12059a87427e97137a3225e6c98e06714da0ffbedc7ad084d"),
				1834508511,
			),
			expect: bloom.Unhexlify("0200222000000001100020600880000000000000001000100000040800800102010000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("b6981b9f5477f82f5bbb65a48c7aee6a05f4ed20e41f091f2781ac150e4ee8e3"),
				1658529405,
			),
			expect: bloom.Unhexlify("0080000200240000000000000000009000000884400400002080040000000000000201"),
		},
	}

	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, Tweak)
		filter.AddOutPoint(c.outPoint)

		if got := filter.Snapshot().Bits; !bytes.Equal(got, c.expect) {
			t.Fatalf("#%d invalid filter: got %x, expect %x", i, got, c.expect)
		}
	}
}

func TestFilter_MatchOutPoint(t *testing.T) {
	// these test cases are generated by running the reference impl
	// from btcsuite/btcutil
	testCases := []*btcwire.OutPoint{
		bloom.NewOutPoint(
			bloom.Unhexlify("2440cddbc2a189357e7bc0e4f552bfde79e7f6b16d41c32436a67fd6db8f5051"),
			1365930811,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("4eae34665dd045f0a5d7c1bfbb3dc7f7dc7e83af6473adb86e5ec294884d16da"),
			2369852057,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("05b1b97ed8376ab33c00bf65edcb6a68951dceeec503a046ce9a0b2e8479ce90"),
			203140287,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("4e8968607d8eccdaa973aab3289e5bc50acc24f0d924644ff5ab8e331e222209"),
			439152913,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("b2d65d20a076eb5ed9fe107c432a4b18da0d0ff5ffbd844a0aedb3240c8f5015"),
			2452721939,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("d2dd5b79a674ab3c59a5455c86e870ef269af79332664999f6c5cd8b62e01902"),
			661960754,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("82155b639c3870f12059a87427e97137a3225e6c98e06714da0ffbedc7ad084d"),
			1834508511,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("b6981b9f5477f82f5bbb65a48c7aee6a05f4ed20e41f091f2781ac150e4ee8e3"),
			1658529405,
		),
	}

	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, Tweak)
		filter.AddOutPoint(c)

		if !filter.MatchOutPoint(c) {
			t.Fatalf("#%d failed to match the added OutPoint", i)
		}
	}
}

func TestFilter_MatchTxAndUpdate_all(t *testing.T) {
	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	tx := bloom.FakeTx(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			"match tx hash only",
			tx,
			[][]byte{
				bloom.Unhexlify("6bff7fcd4f8565ef406dd5d63d4ff94f318fe82027fd4dc451b04474019f74b4"),
			},
			expect{true, bloom.Unhexlify("0000000000001000001820000804000000003010180000200000048000800000004a04")},
		},
		{
			"match the pushed data of the 2nd output",
			tx,
			[][]byte{
				bloom.Unhexlify("a266436d2965547608b9e15d9032a7b9d64fa431"),
			},
			expect{true, bloom.Unhexlify("3000220434020804028000008060000000440a0180481000400402000c008400002480")},
		},
		{
			"match the TxIn's previous output",
			tx,
			[][]byte{
				bloom.Unhexlify("0b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c19000000000"), // this is the serialized previous OutPoint for tx's input
			},
			expect{true, bloom.Unhexlify("00000400000011000000008da000000800000008200000010012200000000000000012")},
		},
		{
			"match the TxIn's 1st pushed data",
			tx,
			[][]byte{
				bloom.Unhexlify("30450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a01"),
			},
			expect{true, bloom.Unhexlify("00000000040000100000110000000000200000000820880000210c0100100010000104")},
		},
		{
			"no match",
			tx,
			nil,
			expect{false, bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, wire.UpdateAll, Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_p2PubKeyOnly(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateP2PubKeyOnly
	)

	block := bloom.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bloom.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("04eaafc2314def4ca98ac970241bcab022b9c1e1f4ea423a20f134c876f2c01ec0f0dd5b2e86e7168cefe0d81113c3807420ce13ad1357231a2252247d97a46a91"),
			},
			expect: expect{true, bloom.Unhexlify("0804010120800801100214340b01091100000020102000410100003000110000000102")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bloom.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bloom.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bloom.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bloom.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bloom.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bloom.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_all2(t *testing.T) {
	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	tx := bloom.FakeTx(t)

	//bf := btcbloom.NewFilter(N, Tweak, P, btcwire.BloomUpdateAll)

	/*
		out2 := tx.MsgTx().TxOut[1]
		out2Data, err := txscript.PushedData(out2.PkScript)
		if nil != err {
			t.Fatal(err)
		}

		for _, elem := range out2Data {
			t.Logf("elem: %x", elem)
			bf.Add(elem)
			t.Logf("bits: %x", bf.MsgFilterLoad().Filter)
			bf.MatchTxAndUpdate(tx)
			t.Logf("bits2: %x", bf.MsgFilterLoad().Filter)
		}*/
	//in1 := tx.MsgTx().TxIn[0]

	/*out := &in1.PreviousOutPoint
	var i [4]byte
	binary.LittleEndian.PutUint32(i[:], out.Index)

	t.Logf("%x", append(out.Hash[:], i[:]...))

	bf.AddOutPoint(&in1.PreviousOutPoint)
	t.Logf("bits: %x", bf.MsgFilterLoad().Filter)
	*/

	/*
		data, err := txscript.PushedData(in1.SignatureScript)
		if nil != err {
			t.Fatal(err)
		}

		for _, elem := range data {
			t.Logf("elem: %x", elem)
			bf.Add(elem)
			t.Logf("bits: %x", bf.MsgFilterLoad().Filter)
			bf.MatchTxAndUpdate(tx)
			t.Logf("bits: %x", bf.MsgFilterLoad().Filter)
		}
	*/

	/* P2PubKeyOnly */
	bf := btcbloom.NewFilter(N, Tweak, P, btcwire.BloomUpdateP2PubkeyOnly)

	out2 := tx.MsgTx().TxOut[1]
	out2Data, err := txscript.PushedData(out2.PkScript)
	if nil != err {
		t.Fatal(err)
	}

	for _, elem := range out2Data {
		t.Logf("elem: %x", elem)
		bf.Add(elem)
		t.Logf("bits: %x", bf.MsgFilterLoad().Filter)
		bf.MatchTxAndUpdate(tx)
		t.Logf("bits2: %x", bf.MsgFilterLoad().Filter)
	}
	/* end P2PubKeyOnly */
}

func TestHello(t *testing.T) {
	block := bloom.ReadBlock(t)

	for i, tx := range block.Transactions {
		for _, out := range tx.TxOut {
			t.Log(i, txscript.GetScriptClass(out.PkScript))
		}
	}

	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	const format = `{
	description: "%s",
	tx: btcutil.NewTx(block.Transactions[%d]),
	preAdded: [][]byte{
		bloom.Unhexlify("%x"),
	},
	expect: expect{%v, bloom.Unhexlify("%x")},
}
`

	bf := btcbloom.NewFilter(N, bloom.Tweak, P, btcwire.BloomUpdateP2PubkeyOnly)

	// P2PubKeyOnly
	// match tx hash only
	/*
		tx := block.Transactions[0]
		hash := tx.TxHash()
		bf.Add(hash[:])
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match tx hash only", 0, hash[:], ok, bits)
	*/

	/*
		tx := block.Transactions[0]
		out := tx.TxOut[0]
		outData, err := txscript.PushedData(out.PkScript)
		if nil != err {
			t.Fatal(err)
		}
		preAdded := outData[len(outData)-1]

		bf.Add(preAdded)
		t.Logf("%x", bf.MsgFilterLoad().Filter)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match elem in output's PkScript", 0, preAdded, ok, bits)
	*/

	/*
		const idx = 1
		tx := block.Transactions[idx]
		out := tx.TxOut[idx]
		outData, err := txscript.PushedData(out.PkScript)
		if nil != err {
			t.Fatal(err)
		}
		preAdded := outData[len(outData)-1]

		bf.Add(preAdded)
		t.Logf("%x", bf.MsgFilterLoad().Filter)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match elem in output's PkScript without update due to update rule", idx, preAdded, ok, bits)
	*/

	/*
		const idx = 2
		tx := block.Transactions[idx]
		outPoint := &tx.TxIn[0].PreviousOutPoint
		var i [4]byte
		binary.LittleEndian.PutUint32(i[:], outPoint.Index)
		preAdded := append(outPoint.Hash[:], i[:]...)

		bf.Add(preAdded)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match OutPoint in TxIn", idx, preAdded, ok, bits)
	*/

	const idx = 3
	tx := block.Transactions[idx]
	data, _ := txscript.PushedData(tx.TxIn[0].SignatureScript)
	preAdded := data[0]

	bf.Add(preAdded)
	ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
	bits := bf.MsgFilterLoad().Filter
	t.Logf(format, "match 1st pushed element of SignatureScript in TxIn", idx, preAdded, ok, bits)
}
