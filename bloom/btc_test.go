package bloom_test

import (
	"bytes"
	"testing"

	"github.com/sammy00/bip37/wire"

	"github.com/btcsuite/btcd/txscript"
	btcwire "github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
	btcbloom "github.com/btcsuite/btcutil/bloom"
	"github.com/sammy00/bip37/bloom"
)

func TestFilter_AddOutPoint(t *testing.T) {
	// these test cases are generated by running the reference impl
	// from btcsuite/btcutil
	testCases := []struct {
		outPoint *btcwire.OutPoint
		expect   []byte
	}{
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("2440cddbc2a189357e7bc0e4f552bfde79e7f6b16d41c32436a67fd6db8f5051"),
				1365930811,
			),
			expect: bloom.Unhexlify("0180020010100010028023010110020000000040000000001000000004000000000008"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("4eae34665dd045f0a5d7c1bfbb3dc7f7dc7e83af6473adb86e5ec294884d16da"),
				2369852057,
			),
			expect: bloom.Unhexlify("c00000800800000100820030004200000a000001400012000000000001000000200000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("05b1b97ed8376ab33c00bf65edcb6a68951dceeec503a046ce9a0b2e8479ce90"),
				203140287,
			),
			expect: bloom.Unhexlify("000000040000080a040000080280000000000080241010000000020040000080000061"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("4e8968607d8eccdaa973aab3289e5bc50acc24f0d924644ff5ab8e331e222209"),
				439152913,
			),
			expect: bloom.Unhexlify("1800000200090000480100008000002000090800000000080000400000002000008800"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("b2d65d20a076eb5ed9fe107c432a4b18da0d0ff5ffbd844a0aedb3240c8f5015"),
				2452721939,
			),
			expect: bloom.Unhexlify("0000100029008000000800000000001200000000100000000006880800408080810000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("d2dd5b79a674ab3c59a5455c86e870ef269af79332664999f6c5cd8b62e01902"),
				661960754,
			),
			expect: bloom.Unhexlify("0c80000040000800500000000004010000050300040280002000000000000000400000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("82155b639c3870f12059a87427e97137a3225e6c98e06714da0ffbedc7ad084d"),
				1834508511,
			),
			expect: bloom.Unhexlify("0200222000000001100020600880000000000000001000100000040800800102010000"),
		},
		{
			outPoint: bloom.NewOutPoint(
				bloom.Unhexlify("b6981b9f5477f82f5bbb65a48c7aee6a05f4ed20e41f091f2781ac150e4ee8e3"),
				1658529405,
			),
			expect: bloom.Unhexlify("0080000200240000000000000000009000000884400400002080040000000000000201"),
		},
	}

	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, Tweak)
		filter.AddOutPoint(c.outPoint)

		if got := filter.Snapshot().Bits; !bytes.Equal(got, c.expect) {
			t.Fatalf("#%d invalid filter: got %x, expect %x", i, got, c.expect)
		}
	}
}

func TestFilter_MatchOutPoint(t *testing.T) {
	// these test cases are generated by running the reference impl
	// from btcsuite/btcutil
	testCases := []*btcwire.OutPoint{
		bloom.NewOutPoint(
			bloom.Unhexlify("2440cddbc2a189357e7bc0e4f552bfde79e7f6b16d41c32436a67fd6db8f5051"),
			1365930811,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("4eae34665dd045f0a5d7c1bfbb3dc7f7dc7e83af6473adb86e5ec294884d16da"),
			2369852057,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("05b1b97ed8376ab33c00bf65edcb6a68951dceeec503a046ce9a0b2e8479ce90"),
			203140287,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("4e8968607d8eccdaa973aab3289e5bc50acc24f0d924644ff5ab8e331e222209"),
			439152913,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("b2d65d20a076eb5ed9fe107c432a4b18da0d0ff5ffbd844a0aedb3240c8f5015"),
			2452721939,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("d2dd5b79a674ab3c59a5455c86e870ef269af79332664999f6c5cd8b62e01902"),
			661960754,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("82155b639c3870f12059a87427e97137a3225e6c98e06714da0ffbedc7ad084d"),
			1834508511,
		),
		bloom.NewOutPoint(
			bloom.Unhexlify("b6981b9f5477f82f5bbb65a48c7aee6a05f4ed20e41f091f2781ac150e4ee8e3"),
			1658529405,
		),
	}

	const (
		N          = 10
		Tweak      = bloom.Tweak
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, Tweak)
		filter.AddOutPoint(c)

		if !filter.MatchOutPoint(c) {
			t.Fatalf("#%d failed to match the added OutPoint", i)
		}
	}
}

func TestFilter_MatchTx(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateNone
	)

	block := bloom.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bloom.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bloom.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bloom.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bloom.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bloom.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bloom.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bloom.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTx(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_all(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	block := bloom.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bloom.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript#0",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("04eaafc2314def4ca98ac970241bcab022b9c1e1f4ea423a20f134c876f2c01ec0f0dd5b2e86e7168cefe0d81113c3807420ce13ad1357231a2252247d97a46a91"),
			},
			expect: expect{true, bloom.Unhexlify("0804010120800801100214340b01091100000020102000410100003000110000000102")},
		},
		{
			description: "match elem in output's PkScript#1",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bloom.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bloom.Unhexlify("12001284424202041002028000000e0000110001010030018200000404000c08011000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bloom.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bloom.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bloom.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bloom.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_badPkScript(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	block := bloom.ReadBlock(t)

	tx := block.Transactions[1]

	// introduce corruption
	tx.TxOut[0].PkScript = bloom.Unhexlify("6de59c34381a159e95fc6b8775558c5c63bcceeaeb576eb53b")

	out := tx.TxOut[1]
	outData, err := txscript.PushedData(out.PkScript)
	if nil != err {
		t.Fatal(err)
	}
	preAdded := outData[len(outData)-1]

	expect := bloom.Unhexlify("1004020440420225150002002001800010000000010000008200200400008908810410")

	filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
	filter.Add(preAdded)

	if got := filter.MatchTxAndUpdate(btcutil.NewTx(tx)); !got {
		t.Fatalf("matching is expected")
	}

	if bits := filter.Snapshot().Bits; !bytes.Equal(bits, expect) {
		t.Fatalf("invalid bits: got %x, expect %x", bits, expect)
	}
}

func TestFilter_MatchTxAndUpdate_badSignatureScript(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	block := bloom.ReadBlock(t)

	tx := block.Transactions[1]

	// introduce corruption
	//io.ReadFull(rand.Reader, tx.TxIn[0].SignatureScript)
	tx.TxIn[0].SignatureScript = bloom.Unhexlify("4fd580192a4b534058fb7b0bc98324d79dd41c073294889b963880e256aeac810e74f8f178063c318517a37d4eecb2db0f797fa1e9d4bf95f928fb31b583d346554c16613661400e1a")

	expect := bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")

	filter := bloom.New(N, P, UpdateRule, bloom.Tweak)

	if got := filter.MatchTxAndUpdate(btcutil.NewTx(tx)); got {
		t.Fatalf("non-matching is expected")
	}

	if bits := filter.Snapshot().Bits; !bytes.Equal(bits, expect) {
		t.Fatalf("invalid bits: got %x, expect %x", bits, expect)
	}
}

func TestFilter_MatchTxAndUpdate_none(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateNone
	)

	block := bloom.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bloom.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bloom.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bloom.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bloom.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bloom.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bloom.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bloom.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestFilter_MatchTxAndUpdate_p2PubKeyOnly(t *testing.T) {
	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateP2PubKeyOnly
	)

	block := bloom.ReadBlock(t)

	type expect struct {
		ok   bool
		bits []byte
	}
	testCases := []struct {
		description string
		tx          *btcutil.Tx
		preAdded    [][]byte
		expect      expect
	}{
		{
			description: "match tx hash only",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("0b3674c6e50f36f36f7a9f485e76c7868bf4d9f5984eaa0b5996657876aa7c14"),
			},
			expect: expect{true, bloom.Unhexlify("1000000000000800000000080000040000200400a04800008108000008014080044000")},
		},
		{
			description: "match elem in output's PkScript and update",
			tx:          btcutil.NewTx(block.Transactions[0]),
			preAdded: [][]byte{
				bloom.Unhexlify("04eaafc2314def4ca98ac970241bcab022b9c1e1f4ea423a20f134c876f2c01ec0f0dd5b2e86e7168cefe0d81113c3807420ce13ad1357231a2252247d97a46a91"),
			},
			expect: expect{true, bloom.Unhexlify("0804010120800801100214340b01091100000020102000410100003000110000000102")},
		},
		{
			description: "match elem in output's PkScript without update due to update rule",
			tx:          btcutil.NewTx(block.Transactions[1]),
			preAdded: [][]byte{
				bloom.Unhexlify("1b8dd13b994bcfc787b32aeadf58ccb3615cbd54"),
			},
			expect: expect{true, bloom.Unhexlify("1000020440420204100002000000000000000000010000008200000400000808010000")},
		},
		{
			description: "match OutPoint in TxIn",
			tx:          btcutil.NewTx(block.Transactions[2]),
			preAdded: [][]byte{
				bloom.Unhexlify("fdacf9b3eb077412e7a968d2e4f11b9a9dee312d666187ed77ee7d26af16cb0b00000000"),
			},
			expect: expect{true, bloom.Unhexlify("0000000000021040050002000000202800000000008000000000004100020100001000")},
		},
		{
			description: "match 1st pushed element of SignatureScript in TxIn",
			tx:          btcutil.NewTx(block.Transactions[3]),
			preAdded: [][]byte{
				bloom.Unhexlify("304502200c45de8c4f3e2c1821f2fc878cba97b1e6f8807d94930713aa1c86a67b9bf1e40221008581abfef2e30f957815fc89978423746b2086375ca8ecf359c85c2a5b7c88ad01"),
			},
			expect: expect{true, bloom.Unhexlify("4004000000b00000000010020000080040108000000040400080000000000084002808")},
		},
		{
			"no match",
			btcutil.NewTx(block.Transactions[0]),
			nil,
			expect{false, bloom.Unhexlify("0000000000000000000000000000000000000000000000000000000000000000000000")},
		},
	}

	for i, c := range testCases {
		filter := bloom.New(N, P, UpdateRule, bloom.Tweak)
		for _, data := range c.preAdded {
			filter.Add(data)
		}

		if got := filter.MatchTxAndUpdate(c.tx); got != c.expect.ok {
			t.Fatalf("#%d invalid matching status: got %v, expect %v", i, got,
				c.expect.ok)
		}

		if bits := filter.Snapshot().Bits; !bytes.Equal(bits, c.expect.bits) {
			t.Fatalf("#%d invalid bits: got %x, expect %x", i, bits, c.expect.bits)
		}
	}
}

func TestHello(t *testing.T) {
	block := bloom.ReadBlock(t)

	//for i, tx := range block.Transactions {
	//	for _, out := range tx.TxOut {
	//		t.Log(i, txscript.GetScriptClass(out.PkScript))
	//	}
	//}

	const (
		N          = 10
		P          = 0.000001
		UpdateRule = wire.UpdateAll
	)

	const format = `{
	description: "%s",
	tx: btcutil.NewTx(block.Transactions[%d]),
	preAdded: [][]byte{
		bloom.Unhexlify("%x"),
	},
	expect: expect{%v, bloom.Unhexlify("%x")},
}
`

	bf := btcbloom.NewFilter(N, bloom.Tweak, P, btcwire.BloomUpdateAll)
	//bf := btcbloom.NewFilter(N, bloom.Tweak, P, btcwire.BloomUpdateP2PubkeyOnly)
	//bf := btcbloom.NewFilter(N, bloom.Tweak, P, btcwire.BloomUpdateNone)

	// P2PubKeyOnly
	// match tx hash only
	/*
		tx := block.Transactions[0]
		hash := tx.TxHash()
		bf.Add(hash[:])
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match tx hash only", 0, hash[:], ok, bits)
	*/

	/*
		tx := block.Transactions[0]
		out := tx.TxOut[0]
		outData, err := txscript.PushedData(out.PkScript)
		if nil != err {
			t.Fatal(err)
		}
		preAdded := outData[len(outData)-1]

		bf.Add(preAdded)
		//t.Logf("%x", bf.MsgFilterLoad().Filter)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match elem in output's PkScript", 0, preAdded, ok, bits)
	*/

	/*
		const idx = 1
		tx := block.Transactions[idx]
		out := tx.TxOut[idx]
		outData, err := txscript.PushedData(out.PkScript)
		if nil != err {
			t.Fatal(err)
		}
		preAdded := outData[len(outData)-1]

		bf.Add(preAdded)
		//t.Logf("%x", bf.MsgFilterLoad().Filter)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match elem in output's PkScript without update due to update rule", idx, preAdded, ok, bits)
	*/

	/*
		const idx = 2
		tx := block.Transactions[idx]
		outPoint := &tx.TxIn[0].PreviousOutPoint
		var i [4]byte
		binary.LittleEndian.PutUint32(i[:], outPoint.Index)
		preAdded := append(outPoint.Hash[:], i[:]...)

		bf.Add(preAdded)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match OutPoint in TxIn", idx, preAdded, ok, bits)
	*/

	/*
		const idx = 3
		tx := block.Transactions[idx]
		data, _ := txscript.PushedData(tx.TxIn[0].SignatureScript)
		preAdded := data[0]

		bf.Add(preAdded)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match 1st pushed element of SignatureScript in TxIn", idx,
			preAdded, ok, bits)
	*/

	// corrupt PkScript in TxOut
	/*
		const idx = 1
		tx := block.Transactions[idx]

		//t.Logf("%x", tx.TxOut[0].PkScript)
		//io.ReadFull(rand.Reader, tx.TxOut[0].PkScript)
		tx.TxOut[0].PkScript = bloom.Unhexlify("6de59c34381a159e95fc6b8775558c5c63bcceeaeb576eb53b")
		//t.Logf("%x", tx.TxOut[0].PkScript)

		out := tx.TxOut[1]
		outData, err := txscript.PushedData(out.PkScript)
		if nil != err {
			t.Fatal(err)
		}
		preAdded := outData[len(outData)-1]

		bf.Add(preAdded)
		ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
		bits := bf.MsgFilterLoad().Filter
		t.Logf(format, "match elem in output's PkScript and update given some bad TxOut.PkScripts", idx, preAdded, ok, bits)
	*/

	// corrupt SignatureScript in TxIn
	const idx = 1
	tx := block.Transactions[idx]

	t.Logf("%x", tx.TxIn[0].SignatureScript)
	//io.ReadFull(rand.Reader, tx.TxIn[0].SignatureScript)
	tx.TxIn[0].SignatureScript = bloom.Unhexlify("bad signature script")
	//tx.TxOut[0].PkScript = bloom.Unhexlify("6de59c34381a159e95fc6b8775558c5c63bcceeaeb576eb53b")
	//t.Logf("%x", tx.TxOut[0].PkScript)

	ok := bf.MatchTxAndUpdate(btcutil.NewTx(tx))
	bits := bf.MsgFilterLoad().Filter
	t.Logf(format, "match elem in output's PkScript and update given some bad TxOut.PkScripts", idx, "", ok, bits)
}
